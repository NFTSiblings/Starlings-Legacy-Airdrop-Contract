// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/**************************************************************\
 * CenterFacetLib authored by Sibling Labs
 * Version 0.2.0
 * 
 * This contract has been designed as part of a 
/**************************************************************/

import "../ancillary/ERC721DiamondStorage.sol";

library CenterFacetLib {
    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256("starlingslegacy.centerfacet.storage");

    struct state {
        address authorisedSigner;
        string baseURI;
        bool burnsPermitted;
        mapping(address => bool) transferPermitted;
        mapping(uint256 => bool) transferPermittedTokens;
    }

    /**
    * @dev Return stored state struct.
    */
    function getState() internal pure returns (state storage _state) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        assembly {
            _state.slot := position
        }
    }
}

/**************************************************************\
 * CenterFacet authored by Sibling Labs
 * Version 0.2.0
 * 
 * This facet contract has been written specifically for
 * ERC721A-DIAMOND-TEMPLATE by Sibling Labs
/**************************************************************/

import { GlobalState } from "../libraries/GlobalState.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract CenterFacet is ERC721 {
    using ECDSA for bytes32;
    using ECDSA for bytes;

    modifier restricted {
        GlobalState.requireCallerIsAdmin();
        _;
    }

    modifier whenNotPaused {
        GlobalState.requireContractIsNotPaused();
        _;
    }

    // VARIABLE GETTERS //

    function authorisedSigner() external view returns (address) {
        return CenterFacetLib.getState().authorisedSigner;
    }

    function baseURI() external view returns (string memory) {
        return _baseURI();
    }

    function burnsPermitted() external view returns (bool) {
        return CenterFacetLib.getState().burnsPermitted;
    }

    function transferPermitted(address addr) external view returns (bool) {
        return CenterFacetLib.getState().transferPermitted[addr];
    }

    function transferPermitted(uint256 tokenId) external view returns (bool) {
        return CenterFacetLib.getState().transferPermittedTokens[tokenId];
    }

    // ADMIN FUNCTIONS //

    function toggleBurnPermission() external restricted {
        CenterFacetLib.getState().burnsPermitted =
        !CenterFacetLib.getState().burnsPermitted;
    }

    function setBaseURI(string memory uri) external restricted {
        CenterFacetLib.getState().baseURI = uri;
    }

    function setAuthorisedSigner(address s) external restricted {
        CenterFacetLib.getState().authorisedSigner = s;
    }

    function toggleTransferPermission(address addr) external restricted {
        CenterFacetLib.getState().transferPermitted[addr] =
        !CenterFacetLib.getState().transferPermitted[addr];
    }

    function toggleTransferPermission(uint256 tokenId) external restricted {
        CenterFacetLib.getState().transferPermittedTokens[tokenId] =
        !CenterFacetLib.getState().transferPermittedTokens[tokenId];
    }

    function reserve(uint256 tokenId) external restricted {
        _safeMint(msg.sender, tokenId);
    }

    // PUBLIC FUNCTIONS //

    /// @param signature a bytes signature generated by the authorised signer
    ///                  containing the address of the minting wallet, and
    ///                  the ID of the token to be minted
    function mint(uint256 tokenId, bytes calldata signature) external whenNotPaused {
        require(
            abi.encodePacked(msg.sender, tokenId)
            .toEthSignedMessageHash()
            .recover(signature) == CenterFacetLib.getState().authorisedSigner,
            "CenterFacet: invalid signature"
        );

        _safeMint(msg.sender, tokenId);
    }

    function burn(uint256 tokenId) external whenNotPaused {
        require(
            GlobalState.isAdmin(msg.sender) ||
            CenterFacetLib.getState().burnsPermitted,
            "CenterFacet: token burning prohibited"
        );

        _burn(tokenId);
    }

    // METADATA & MISC FUNCTIONS //

    function exists(uint256 tokenId) external view returns (bool) {
        return _exists(tokenId);
    }

    function _baseURI() internal view override returns (string memory) {
        return CenterFacetLib.getState().baseURI;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);

        CenterFacetLib.state storage s = CenterFacetLib.getState();

        require(
            from == address(0) ||
            to == address(0) ||
            GlobalState.isAdmin(msg.sender) ||
            s.transferPermitted[from] ||
            s.transferPermittedTokens[tokenId],
            "CenterFacet: token transfers prohibited"
        );
    }
}